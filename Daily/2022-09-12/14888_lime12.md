# 문제 
연산자 끼워넣기
# 시간 
29m

# 소스코드

```python
from sys import stdin
from itertools import permutations 
input = stdin.readline
N = int(input())
arr = list(map(int,input().split()))
l = input().rstrip().split()
lst = [0]*int(l[0])+ [1]*int(l[1])+ [2]*int(l[2])+ [3]*int(l[3])
combis = list(permutations(lst, N-1))
total = []
for coms in combis:
    tmp=arr[0]
    for i in range(len(arr)-1):
        if coms[i] == 0: tmp = tmp+arr[i+1]
        elif coms[i] == 1: tmp = tmp - arr[i+1]
        elif coms[i] == 2: tmp = tmp * arr[i+1]
        else:
            if tmp < 0: tmp = -(abs(tmp) // arr[i+1])
            else: tmp = tmp // arr[i+1]  
    total.append(tmp)

print(max(total), min(total), sep='\n')


```

```python
import sys
from itertools import permutations
input=sys.stdin.readline
n = int(input())
num=list(map(int, input().split()))
op_num=list(map(int, input().split()))
answer=[]

def dfs(depth, total, plus, minus, multiply, divide):
    if depth==n:
        answer.append(total)
        return
    
    if plus:
        dfs(depth+1, total+num[depth], plus-1, minus, multiply, divide)
    if minus:
        dfs(depth+1, total-num[depth], plus, minus-1, multiply, divide)
    if multiply:
        dfs(depth+1, total*num[depth], plus, minus, multiply-1, divide)
    if divide:
        dfs(depth+1, int(total/num[depth]), plus, minus, multiply, divide-1)
        
dfs(1, num[0], op_num[0], op_num[1], op_num[2], op_num[3])

print(max(answer))
print(min(answer))
```

# 풀이
- 모든 부호 조합(0,1,0,2 -> 1,3,3)을 중복순열한 후, 이를 모두 for문으로 돌려 가장 큰 값과 작은 값을 찾아낸다. 
- 두 번째, 풀이의 경우 dfs로 풀이한다. 여기서 핵심은 모든 부호부터 시작할 수 있도록 if 조건을 나란히 배열하고 뎁스를 이용하여 종료 조건을 만드는 것이다. 한 부호로 시작된 dfs는 결국 다른 부호가 0이 될 때까지 걸리게 되어있다. 

# 기록
- 처음 풀이 코드의 경우 부호를 중복순열로 모든 경우의 수에 대해 다 계산을 해보고 그 결과를 반환한다. 이런 경우 Pypy3으로 하였을 때, 통과하였지만 충격적인 메모리와 시간을 자랑한다. 
- 이 때문에, 다른 사람들의 아이디어를 참조하였으며 DFS 풀이방법이 매우 빠른것(88m) 을 확인하여, 이 아이디어를 참조하여 다시 작성하도록 하였다. 
