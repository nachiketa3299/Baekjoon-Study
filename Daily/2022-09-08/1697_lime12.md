# 문제 
숨바꼭질 

# 시간 
57m (실패) 
재풀이 - 0910

# 소스코드

```python

from collections import deque
N, K = map(int, input().split())

dp = [0] * (K+1)

que = deque()
que.append(N)

while que:
    now = que.popleft()
    if now+1 <=K and dp[now+1] == 0:
        dp[now+1] = dp[now] + 1
        que.append(now+1)
    
    if now-1 >=0 and dp[now-1] == 0:
        dp[now-1] = dp[now] + 1 
        que.append(now-1)
    
    if 2*now <=K and dp[2*now] == 0:
        dp[2*now] = dp[now] + 1
        que.append(2*now)

print(dp[-1])


```
(2)
```python

```

# 풀이
- DP+DFS 이용해서 문제를 풀이한다. 
- 처음 코드의 경우 조건에 걸리면서 dp 테이블을 변화시키기 때문에 그 다음 조건에 영향을 주게 되고 문제가 생기며, dp 테이블도 문제이다. K까지로 조건을 주게 되면 순간이동으로 K+1 로 갔다가 돌아오는 케이스는 피해가게 된다. 또, 따라서 K+2로 줘야한다. 
